## 《redis核心技术与实战》
### 01-基本架构
RocksDB以动态链接库的形式使用，而Memcached和Redis则是通过网络框架访问
网络连接的处理、网络请求的解析，以及数据存取的处理，是用一个线程、多个线程，还是多个进程来交互处理呢？该如何进行设计和取舍呢？我们一般把这个问题称为I/O模型设计。不同的I/O模型对键值数据库的性能和可扩展性会有不同的影响。
如果一个线程既要处理网络连接、解析请求，又要完成数据存取，一旦某一步操作发生阻塞，整个线程就会阻塞住，这就降低了系统响应速度。如果我们采用不同线程处理不同操作，那么，某个线程被阻塞时，其他线程还能正常运行。但是，不同线程间如果需要访问共享资源，那又会产生线程竞争。
Redis是单线程，那么，Redis又是如何做到“单线程，高性能”的呢？
哈希表、B+树、字典树等。不同的索引结构在性能、空间消耗、并发控制等方面具有不同的特征。
Memcached和Redis采用哈希表作为key-value索引，RocksDB则采用跳表作为内存中key-value的索引。 -- 因为redis是内存存储的。内存的高性能随机访问特性可以很好地与哈希表O(1)的操作复杂度相匹配
Redis的内存分配器提供了多种选择，分配效率也不一样
Redis主要通过网络框架进行访问，而不再是动态库了，这也使得Redis可以作为一个基础性的网络服务进行访问，扩大了Redis的应用范围。
Redis数据模型中的value类型很丰富，因此也带来了更多的操作接口，例如面向列表的LPUSH/LPOP，面向集合的SADD/SREM等。在下节课，我将和你聊聊这些value模型背后的数据结构和操作效率，以及它们对Redis性能的影响。
Redis的持久化模块能支持两种方式：日志（AOF）和快照（RDB），这两种持久化方式具有不同的优劣势，影响到Redis的访问性能和可靠性。
SimpleKV是个简单的单机键值数据库，但是，Redis支持高可靠集群和高可扩展集群，因此，Redis中包含了相应的集群功能支撑模块。
### 02-数据结构：快速的Redis有哪些慢操作？
接收到一个键值对操作后，能以微秒级别的速度找到数据。
哈希表的冲突问题和rehash可能带来的操作阻塞。
渐进式rehash。
### 03-高性能IO模型：为什么单线程Redis能那么快？
Redis是单线程，主要是指Redis的网络IO和键值对读写是由一个线程来完成的，这也是Redis对外提供键值存储服务的主要流程。但Redis的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。
多线程编程模式面临的共享资源的并发访问控制问题。
每秒数十万级别的处理能力。
内存操作、多路复用机制。

Redis单线程处理IO请求性能瓶颈主要包括2个方面：
1、任意一个请求在server中一旦发生耗时，都会影响整个server的性能，也就是说后面的请求都要等前面这个耗时请求处理完成，自己才能被处理到。耗时的操作包括以下几种：
a、操作bigkey：写入一个bigkey在分配内存时需要消耗更多的时间，同样，删除bigkey释放内存同样会产生耗时；
b、使用复杂度过高的命令：例如SORT/SUNION/ZUNIONSTORE，或者O(N)命令，但是N很大，例如lrange key 0 -1一次查询全量数据；
c、大量key集中过期：Redis的过期机制也是在主线程中执行的，大量key集中过期会导致处理一个请求时，耗时都在删除过期key，耗时变长；
d、淘汰策略：淘汰策略也是在主线程执行的，当内存超过Redis内存上限后，每次写入都需要淘汰一些key，也会造成耗时变长；
e、AOF刷盘开启always机制：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢Redis的性能；
f、主从全量同步生成RDB：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久；
2、并发量非常大时，单线程读写客户端IO数据存在性能瓶颈，虽然采用IO多路复用机制，但是读写客户端数据依旧是同步IO，只能单线程依次读取客户端的数据，无法利用到CPU多核。

针对问题1，一方面需要业务人员去规避，一方面Redis在4.0推出了lazy-free机制，把bigkey释放内存的耗时操作放在了异步线程中执行，降低对主线程的影响。

针对问题2，Redis在6.0推出了多线程，可以在高并发场景下利用CPU多核多线程读写客户端数据，进一步提升server性能，当然，只是针对客户端的读写是并行的，每个命令的真正操作依旧是单线程的

https://news.ycombinator.com/item?id=1171423
##### 非阻塞模式
针对监听套接字，我们可以设置非阻塞模式：当Redis调用accept()但一直未有连接请求到达时，Redis线程可以返回处理其他操作。
可以针对已连接套接字设置非阻塞模式：Redis调用recv()后，如果已连接套接字上一直没有数据到达，Redis线程同样可以返回处理其他操作。
##### 基于多路复用的高性能I/O模型
Redis只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给Redis线程处理，这就实现了一个Redis线程处理多个IO流的效果。
为了在请求到达时能通知到Redis线程，select/epoll提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数。
既有基于Linux系统下的select和epoll实现，也有基于FreeBSD的kqueue实现，以及基于Solaris的evport实现，这样，你可以根据Redis实际运行的操作系统，选择相应的多路复用实现。


### 04-AOF日志：宕机了，Redis如何避免数据丢失？
数据库的写前日志（Write Ahead Log, WAL）
AOF日志正好相反，它是写后日志。
写后，可以避免出现记录错误命令的情况。
在命令执行后才记录日志，所以不会阻塞当前的写操作。
刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。
AOF配置项appendfsync ： Always  Everysec  No
和AOF日志由主线程写回不同，重写过程是由后台线程bgrewriteaof来完成的，这也是为了避免阻塞主线程，导致数据库性能下降。
“一个拷贝，两处日志”
AOF日志重写的时候，是由bgrewriteaof子进程来完成的，不用主线程参与，我们今天说的非阻塞也是指子进程的执行不阻塞主线程。
问题1，Redis采用fork子进程重写AOF文件时，潜在的阻塞风险包括：fork子进程 和 AOF重写过程中父进程产生写入的场景，下面依次介绍。
there is no denying that  what can not be neglected  is that
a、fork子进程，fork这个瞬间一定是会阻塞主线程的（注意，fork时并不会一次性拷贝所有内存数据给子进程，老师文章写的是拷贝所有内存数据给子进程，我个人认为是有歧义的），fork采用操作系统提供的写实复制(Copy On Write)机制，就是为了避免一次性拷贝大量内存数据给子进程造成的长时间阻塞问题，但fork子进程需要拷贝进程必要的数据结构，其中有一项就是拷贝内存页表（虚拟内存和物理内存的映射索引表），这个拷贝过程会消耗大量CPU资源，拷贝完成之前整个进程是会阻塞的，阻塞时间取决于整个实例的内存大小，实例越大，内存页表越大，fork阻塞时间越久。拷贝内存页表完成后，子进程与父进程指向相同的内存地址空间，也就是说此时虽然产生了子进程，但是并没有申请与父进程相同的内存大小。那什么时候父子进程才会真正内存分离呢？“写实复制”顾名思义，就是在写发生时，才真正拷贝内存真正的数据，这个过程中，父进程也可能会产生阻塞的风险，就是下面介绍的场景。

b、fork出的子进程指向与父进程相同的内存地址空间，此时子进程就可以执行AOF重写，把内存中的所有数据写入到AOF文件中。但是此时父进程依旧是会有流量写入的，如果父进程操作的是一个已经存在的key，那么这个时候父进程就会真正拷贝这个key对应的内存数据，申请新的内存空间，这样逐渐地，父子进程内存数据开始分离，父子进程逐渐拥有各自独立的内存空间。因为内存分配是以页为单位进行分配的，默认4k，如果父进程此时操作的是一个bigkey，重新申请大块内存耗时会变长，可能会产阻塞风险。另外，如果操作系统开启了内存大页机制(Huge Page，页面大小2M)，那么父进程申请内存时阻塞的概率将会大大提高，所以在Redis机器上需要关闭Huge Page机制。Redis每次fork生成RDB或AOF重写完成后，都可以在Redis log中看到父进程重新申请了多大的内存空间。

问题2，AOF重写不复用AOF本身的日志，一个原因是父子进程写同一个文件必然会产生竞争问题，控制竞争就意味着会影响父进程的性能。二是如果AOF重写过程中失败了，那么原本的AOF文件相当于被污染了，无法做恢复使用。所以Redis AOF重写一个新文件，重写失败的话，直接删除这个文件就好了，不会对原先的AOF文件产生影响。等重写完成之后，直接替换旧文件即可。

![aof](https://static001.geekbang.org/resource/image/57/e1/5770a4f81fb0469656fef2b35d354fe1.jpg)
AOF对于过期key不会特殊处理，因为Redis keys过期有两种方式：被动和主动方式。
当一些客户端尝试访问它时，key会被发现并主动的过期。

Redis每秒10次做的事情：
测试随机的20个keys进行相关过期检测。
删除所有已经过期的keys。
如果有多于25%的keys过期，重复步奏1.

在 redis.conf 文件中配置重写的条件，如：
auto-aof-rewrite-min-size 64MB // 当文件小于64M时不进行重写
auto-aof-rewrite-min-percenrage 100 // 当文件比上次重写后的文件大100%时进行重写

### 05-内存快照：宕机后，Redis如何实现快速恢复？

在bgsave子进程和bgrewriteaof子进程运行期间有全量更新redis数据的情况。导致内存翻倍。

save：在主线程中执行，会导致阻塞；
bgsave：创建一个子进程，专门用于写入RDB文件，避免了主线程的阻塞，这也是Redis RDB文件生成的默认配置。

Redis 4.0中提出了一个混合使用AOF日志和内存快照的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用AOF日志记录这期间的所有命令操作。

关于AOF和RDB的选择问题，我想再给你提三点建议：
数据不能丢失时，内存快照和AOF的混合使用是一个很好的选择；
如果允许分钟级别的数据丢失，可以只使用RDB；
如果只用AOF，优先使用everysec的配置选项，因为它在可靠性和性能之间取了一个平衡。

### 06-数据同步：主从库如何实现数据一致？
Redis具有高可靠性，又是什么意思呢？其实，这里有两层含义：一是数据尽量少丢失，二是服务尽量少中断。
replicaof  172.16.19.3  6379
psync：offset(MS), runID(M), backlog(M); 
S发psync <runID> <offset>或PSYNC ? -1, M发+continue或+FULLRESYNC <runid><offset>, M找backlog队列里offset后的数据发给S
通过“主-从-从”模式将主库生成RDB和传输RDB的压力，以级联的方式分散到从库上。
基于长连接的命令传播
网络断连或阻塞
repl_backlog_buffer是一个环形缓冲区，主库会记录自己写到的位置，从库则会记录自己已经读到的位置。master_repl_offset和slave_repl_offset。
repl_backlog_size = (主库写入命令速度 * 操作大小 - 主从库间网络传输命令速度 * 操作大小) * 2
如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被主库新写的操作覆盖了，这会导致主从库间的数据不一致。-- 存疑！

全量复制、基于长连接的命令传播，以及增量复制。
一个Redis实例的数据库不要太大。

###### 主从库间网络断了怎么办？
从Redis 2.8开始，网络断了之后，主从库会采用增量复制的方式继续同步。
当主从库断连后，主库会把断连期间收到的写操作命令，写入replication buffer，同时也会把这些操作命令也写入repl_backlog_buffer这个缓冲区。

### 09-切片集群：数据增多了，是该加内存还是加实例？
25GB，INFO命令查看Redis的latest_fork_usec指标值（表示最近一次fork的耗时）
纵向扩展的好处是，实施起来简单、直接。
- 线程fork子进程时就可能会阻塞
- 受到硬件和成本的限制
面向百万、千万级别的用户规模时，横向扩展的Redis切片集群会是一个非常好的选择
从3.0开始，官方提供了一个名为Redis Cluster的方案
根据键值对的key，按照CRC16算法计算一个16 bit的值；然后，再用这个16bit值对16384取模，得到0~16383范围内的模数，每个模数代表一个相应编号的哈希槽。
在手动分配哈希槽时，需要把16384个槽都分配完，否则Redis集群无法正常工作。
``` 
redis-cli -h 172.16.19.3 –p 6379 cluster addslots 0,1
redis-cli -h 172.16.19.4 –p 6379 cluster addslots 2,3
redis-cli -h 172.16.19.5 –p 6379 cluster addslots 4
```
客户端收到哈希槽信息后，会把哈希槽信息缓存在本地。当客户端请求键值对时，会先计算键所对应的哈希槽，然后就可以给相应的实例发送请求了。
```shell script
#迁移完成重定向
GET hello:key
(error) MOVED 13320 172.16.19.5:6379

#迁移部分完成的情况
GET hello:key
(error) ASK 13320 172.16.19.5:6379
```
ASK命令表示两层含义：第一，表明Slot数据还在迁移中；第二，ASK命令把客户端所请求数据的最新实例地址返回给客户端，此时，客户端需要给实例3发送ASKING命令，然后再发送操作命令。
和MOVED命令不同，ASK命令并不会更新客户端缓存的哈希槽分配信息。

key的slot点是固定的，无论多少个节点多少个key。实际上对slot做的负载均衡，而不是对key做的负载均衡。 

### 10-第1～9讲课后思考题答案及常见问题答疑
在主线程中，我们还可以使用fork创建子进程，或是使用pthread_create创建线程。下面我先介绍下Redis中用fork创建的子进程有哪些。
- 创建RDB的后台子进程，同时由它负责在主从同步时传输RDB给从库；
- 通过无盘复制方式传输RDB的子进程；
- bgrewriteaof子进程。
- 从4.0版本开始，Redis也开始使用pthread_create创建线程，这些线程在创建后，一般会自行执行一些任务，例如执行异步删除任务的后台线程。
replication buffer和repl_backlog_buffer的区别
- replication buffer是主从库在进行全量复制时，主库上用于和从库连接的客户端的buffer，而repl_backlog_buffer是为了支持从库增量复制
- replication buffer不是共享的，而是每个从库都有一个对应的客户端。
- repl_backlog_buffer是一块专用buffer。不同的从库在进行恢复时，会把自己的复制进度（slave_repl_offset）发给主库，主库就可以和它独立同步。
渐进式 hash
- 定时任务中会 对redis的 数据字典（保存每个键值对数据的dict结构）和过期字典（保存每个键值对过期时间的dict）这两个dict结构进行rehash
- 实例暂时没有收到新请求， 每100ms/次执行的定时任务会定时执行一次rehash操作。

### 11-“万金油”的String，为什么不好用了？
用二级编码的方法，实现了用集合类型保存单值键值对，Redis实例的内存空间消耗明显下降了。
除了记录实际数据，String类型还需要额外的内存空间记录数据长度、空间使用等信息，这些信息也叫作元数据。
包括了RedisObject结构、SDS结构、dictEntry结构的内存开销。
jemalloc在分配内存时，会根据我们申请的字节数N，找一个比N大，但是最接近N的2的幂次数作为分配的空间，这样可以减少频繁分配的次数。
用String，保存有效信息只有16字节时需要用64个字节。
用ziplist，一个图片的存储对象ID所占用的内存大小是14字节（1+4+1+8=14），实际分配16字节。
二级编码方法中采用的ID长度是有讲究的。
为了能充分使用压缩列表的精简内存布局，我们一般要控制保存在Hash集合中的元素个数。
只用图片ID最后3位作为Hash集合的key，也就保证了Hash集合的元素个数不超过1000，同时，我们把hash-max-ziplist-entries设置为1000，这样一来，Hash集合就可以一直使用压缩列表来节省内存空间了。

过期key保存、cluster.slot的所有key、lru控制、
### 12-有一亿个keys要统计，应该用哪种集合？
聚合统计、排序统计、二值状态统计和基数统计。
每个 HyperLogLog只需要花费 12 KB内存，就可以计算接近 2^64 个元素的基数。标准误算率是0.81%
HyperLogLog实际上不会存储每个元素的值，它使用的是概率算法，通过存储元素的hash值的第一个1的位置，来计算元素数量。
对于一个输入的字符串，首先得到64位的hash值，用前14位来定位桶的位置（共有 [公式] ，即16384个桶）。后面50位即为伯努利过程，每个桶有6bit，记录第一次出现1的位置count，如果count>oldcount，就用count替换oldcount。
[!统计](https://static001.geekbang.org/resource/image/c0/6e/c0bb35d0d91a62ef4ca1bd939a9b136e.jpg)


### 13-GEO是什么？还可以定义新的数据类型吗？
GEO类型使用GeoHash编码方法实现了经纬度到Sorted Set中元素权重分数的转换，这其中的两个关键机制就是对二维地图做区间划分，以及对区间进行编码。一组经纬度落在某个区间后，就用区间的编码值来表示，并把编码值作为Sorted Set元素的权重分数。这样一来，我们就可以把经纬度保存到Sorted Set中，利用Sorted Set提供的“按权重进行有序范围查找”的特性，实现LBS服务中频繁使用的“搜索附近”的需求。

### 14-如何在Redis中保存时间序列数据？
使用RedisTimeSeries模块。这是专门为存取时间序列数据而设计的扩展模块。

### 15-消息队列的考验：Redis有哪些解决方案？
分布式系统组件使用消息队列时的三大需求：消息保序、重复消息处理和消息可靠性保证，这三大需求可以进一步转换为对消息队列的三大要求：消息数据有序存取，消息数据具有全局唯一编号，以及消息数据在消费完成后被删除。
[!mq](https://static001.geekbang.org/resource/image/b2/14/b2d6581e43f573da6218e790bb8c6814.jpg)

### 16-异步机制：如何避免单线程模型的阻塞？

[!block](https://static001.geekbang.org/resource/image/6c/22/6ce8abb76b3464afe1c4cb3bbe426922.jpg)
删除操作： 释放内存只是第一步，为了更加高效地管理内存空间，在应用程序释放内存时，操作系统需要把释放掉的内存块插入一个空闲内存块的链表，以便后续进行管理和再分配。空闲内存块链表操作时间。

删除100万个元素的hash用1.98s，10w,50ms; 
[!delTime](https://static001.geekbang.org/resource/image/94/53/94bc8cf9yy5c34a6445434a15b1e9653.jpg)

对于从库来说，它在接收了RDB文件后，需要使用FLUSHDB命令清空当前数据库，会堵塞。
从库在清空当前数据库后，还需要把RDB文件加载到内存，会堵塞。
cluster增删节点均衡数据，数据迁移过程， 哈希槽的信息量不大，而数据迁移是渐进式执行的，影响不大。但迁移的是bigkey的话，就会造成主线程的阻塞。

###### 异步子线程机制
那always也是异步落库么？
惰性删除（lazy free）：  若机器down了可能删除的数据又回来了么？？？ 
主线程通过一个链表形式的任务队列和子线程进行交互。当收到键值对删除和清空数据库的操作时，主线程会把这个操作封装成一个任务，放入到任务队列中，然后给客户端返回一个完成信息，表明删除已经完成。但实际上，这个时候删除还没有执行，等到后台子线程从任务队列中读取任务后，才开始实际删除键值对，并释放相应的内存空间。
删除集合大量元素用UNLINK命令在符合场景下会异步释放内存。  FLUSHDB ASYNC  或 FLUSHALL AYSNC 异步清空。
lazy-free是4.0新增的功能，但是默认是关闭的，需要手动开启。

Redis性能受损的5大阻塞点，包括集合全量查询和聚合操作、bigkey删除、清空数据库、AOF日志同步写，以及从库加载RDB文件。
Redis 4.0之后，bigkey删除、清空数据库、AOF日志同步写不属于关键路径操作，可以使用异步子线程机制来完成。Redis在运行时会创建三个子线程，主线程会通过一个任务队列和三个子线程进行交互。子线程会根据任务的具体类型，来执行相应的异步操作。
集合全量查询和聚合操作、从库加载RDB文件是在关键路径上，无法使用异步操作来完成。
- 使用scan分配读数据，client聚合
- 主库数据量 2-4GB

### 17-为什么CPU结构也会影响Redis的性能？
建议你在Redis运行时，把实例和某个核绑定，这样，就能重复利用核上的L1、L2缓存，可以降低响应延迟。
把网络中断处理程序和CPU核绑定。
NUMA架构把Redis实例和网络中断处理程序绑在同一个CPU Socket下的不同核上
逻辑核绑定后，这些子进程和后台线程会和主线程竞争CPU资源。
- 按一个Redis实例一个物理核方式进行绑定，这样，Redis的主线程、子进程和后台线程可以共享使用一个物理核上的两个逻辑核。
- 在源码中增加绑核操作，把子进程和后台线程绑到不同的核上。 Redis 6.0出来后，可以支持CPU核绑定的配置操作。

### 18-波动的响应延迟：如何应对变慢的Redis？
常情况下，一些难以排查的问题是Redis的用法或设置和底层系统的工作机制不协调导致的。
一个是看响应延迟，一个是看基线性能。
慢查询命令、过期key的时间设置。
在使用SCAN命令时，不会漏key，但可能会得到重复的key，这主要和Redis的Rehash机制有关。


### 19-波动的响应延迟：如何应对变慢的Redis？
基线性能、慢查询、批量过期、bigKey、aof配置、内存使用率、透明大页机制、大rdb同步、多核CPU、正在内存清理、

### 20-删除数据后，为什么内存占用率还是很高？
info memory命令是一个好工具，可以帮助你查看碎片率的情况；
碎片率阈值是一个好经验，可以帮忙你有效地判断是否要进行碎片清理了；
内存碎片自动清理是一个好方法，可以避免因为碎片导致Redis的内存实际利用率降低，提升成本收益率。

### 21-缓冲区：一个可能引发“惨案”的地方
客户端通信：输入和输出缓冲区
主从节点复制：复制缓冲区和复制积压缓冲区
缓冲区溢出导致网络连接关闭。 导致无法读写redis或主从全量同步失败。
缓冲区溢出导致命令数据丢失。 导致全量复制。
三个原因： 命令数据发送过快过大；命令数据处理较慢；缓冲区空间过小。
解决： 避免bigKey、避免大rdb文件、减少堵塞操作、优化client-output-buffer-limit配置项。

### 22-第11～21讲课后思考题答案及常见问题答疑
面向磁盘的写操作一般不会在关键路径上。

用Redis自带的–bigkeys选项排查bigkey，有两个不足的地方：
- 这个方法只能返回每种类型中最大的那个bigkey，无法得到大小排在前N位的bigkey；
- 对于集合类型来说，这个方法只统计集合元素个数的多少，而不是实际占用的内存量。但是，一个集合中的元素个数多，并不一定占用的内存就多。因为，有可能每个元素占用的内存很小，这样的话，即使元素个数有很多，总内存开销也不大。


### 23-旁路缓存：Redis是如何工作的？
只读缓存和读写缓存、同步写异步写。

### 24-替换策略：缓存满了怎么办？
把缓存容量设置为总数据量的15%到30%，兼顾访问性能和内存空间开销。
8种数据淘汰策略。 候选集分全部和有过期时间的。策略有随机、lru、lfu。

### 25-缓存异常（上）：如何解决缓存和数据库的数据不一致问题？
4个方面：缓存中的数据和数据库中的不一致；缓存雪崩；缓存击穿和缓存穿透。
[!cache](https://static001.geekbang.org/resource/image/11/6f/11ae5e620c63de76448bc658fe6a496f.jpg)
优先使用先更新数据库再删除缓存的方法

### 26-缓存异常（下）：如何解决缓存雪崩、击穿、穿透难题？
除了大量数据同时失效会导致缓存雪崩，还有一种情况也会发生缓存雪崩，那就是，Redis缓存实例发生故障宕机了，无法处理请求，这就会导致大量请求一下子积压到数据库层，从而发生缓存雪崩。
在业务系统中实现服务熔断或请求限流机制。

缓存击穿，是发生在某个热点数据失效的场景下。

缓存穿透发生时，数据也不在数据库中
- 第一种方案是，缓存空值或缺省值。
- 第二种方案是，使用布隆过滤器快速判断数据是否存在，避免从数据库中查询数据是否存在，减轻数据库压力。
- 请求入口的前端进行请求检测。
[!cache](https://static001.geekbang.org/resource/image/b5/e1/b5bd931239be18bef24b2ef36c70e9e1.jpg)
解决方案：
- 针对缓存雪崩，合理地设置数据过期时间，以及搭建高可靠缓存集群；
- 针对缓存击穿，在缓存访问非常频繁的热点数据时，不要设置过期时间；
- 针对缓存穿透，提前在入口前端实现恶意请求检测，或者规范数据库的数据删除操作，避免误删除。

### 27-缓存被污染了，该怎么办？
缓存污染问题指的是留存在缓存中的数据，实际不会被再次访问了，但是又占据了缓存空间。
LFU策略在LRU策略基础上进行了优化，在筛选数据时，首先会筛选并淘汰访问次数少的数据，然后针对访问次数相同的数据，再筛选并淘汰访问时间最久远的数据。
相对于LRU策略，Redis只是把原来24bit大小的lru字段，又进一步拆分成了16bit的ldt和8bit的counter，分别用来表示数据的访问时间戳和访问次数。为了避开8bit最大只能记录255的限制，LFU策略设计使用非线性增长的计数器来表示数据的访问次数。
LRU应用广泛； 扫描式查询的应用场景用LFU。 
优先使用volatile-lfu策略，并根据这些数据的访问时限设置它们的过期时间。

### 30-如何使用Redis实现分布式锁？
基于单个Redis实例实现分布式锁：nx、ex、uuid、redis-lua。
Redlock基于多实例。
TODO 
### 32-Redis主从同步与故障切换，有哪些坑？
主从数据不一致、读到过期数据，以及配置项设置得不合理从而导致服务挂掉。
主从库间的命令复制是异步进行的。
在硬件环境配置方面，我们要尽量保证主从库间的网络连接状况良好。
Redis的INFO replication命令可以查看主库接收写命令的进度信息（master_repl_offset）和从库复制写命令的进度信息（slave_repl_offset）
[!slave](https://static001.geekbang.org/resource/image/3a/05/3a89935297fb5b76bfc4808128aaf905.jpg)

Redis同时使用了两种策略来删除过期的数据，分别是惰性删除策略和定期删除策略。
Redis 3.2之前的版本，那么，从库在服务读请求时，并不会判断数据是否过期，而是会返回过期数据。在3.2版本后，Redis做了改进，如果读取的数据已经过期了，从库虽然不会删除，但是会返回空值，这就避免了客户端读到过期数据。所以，在应用主从集群时，尽量使用Redis 3.2及以上版本。
slave-serve-stale-data:从库能否处理数据读写命令;  slave-read-only: 从库能否处理写命令.

在业务应用中使用EXPIREAT/PEXPIREAT命令，把数据的过期时间设置为具体的时间点，避免读到过期数据。
因为EXPIREAT/PEXPIREAT设置的是时间点，所以，主从节点上的时钟要保持一致，具体的做法是，让主从节点和相同的NTP服务器（时间服务器）进行时钟同步。

protected-mode: no; yes会导致哨兵实例间无法通信。  将bind配置项设置为其它哨兵实例的IP地址。
```
protected-mode no
bind 192.168.10.3 192.168.10.4 192.168.10.5
```
cluster，主从切换时间长导致cluster-node-timeout， 若超半数节点超时导致整个集群挂掉。


### 33-脑裂：一次奇怪的数据丢失
主库的数据还没有同步到从库，结果主库发生了故障，等从库升级为主库后，未同步的数据就丢失了。
从库上的slave_repl_offset小于原主库的master_repl_offset，那么，我们就可以认定数据丢失是由数据同步未完成导致的。
排查客户端的操作日志，发现脑裂现象
原主库假故障导致的脑裂, 被哨兵错误地判断为客观下线的。
主库CPU用满，导致Redis主库无法响应心跳。
主从切换后，原主库slave of和新主库重新进行全量同步。原主库因要加载rdb需要清空本地的数据，导致数据丢失。
min-slaves-to-write设置为1，把min-slaves-max-lag设置为12s，把哨兵的down-after-milliseconds设置为10s

假故障原因： 主库CPU高； 主库堵塞如bigKey或内存swap。
_切换过程中，无法找到和原主库保持长链的实例？若无proxy又是如何通知client切主的？_


### 34-第23~33讲课后思考题答案及常见问题答疑
TODO 

### 35-CodisVSRedisCluster：我该选择哪一个集群方案？

![image](https://static001.geekbang.org/resource/image/8f/b8/8fec8c2f76e32647d055ae6ed8cfbab8.jpg)
###### 数据分布
数据分布的实现方法上，Codis和Redis Cluster很相似，都采用了key映射到Slot、Slot再分配到实例上的机制。

Codis中的路由表是我们通过codis dashboard分配和修改的，并被保存在Zookeeper集群中。一旦数据位置发生变化（例如有实例增减），路由表被修改了，codis dashbaord就会把修改后的路由表发送给codis proxy，proxy就可以根据最新的路由信息转发请求了。

在Redis Cluster中，数据路由表是通过每个实例相互间的通信传递的，最后会在每个实例上保存一份。当数据路由信息发生变化时，就需要在所有实例间通过网络消息进行传递。所以，如果实例数量较多的话，就会消耗较多的集群网络资源。

###### 集群扩容和数据迁移如何进行?
###### 选型
codis集群复杂性高、client可复用、仅支持到redis3.2.8无新版本特性、可异步迁移。
![image](https://static001.geekbang.org/resource/image/c7/a5/c726e3c5477558fa1dba13c6ae8a77a5.jpg)

###### 

### 36-Redis支撑秒杀场景的关键技术和实践都有哪些？
前端静态页面的设计、请求拦截和流控、库存信息过期时间处理、数据库订单异常处理。 

### 37-数据分布优化：如何应对数据倾斜？
数据量倾斜：bigKey、slot手工分配、使用hashtag.
数据访问倾斜: 热点数据。

### 38-通信开销：限制RedisCluster规模的关键因素
Redis Cluster实例间以Gossip协议进行通信的机制。
把Redis Cluster 的规模控制在400~500个实例。8wQPS*500=2kwQPS。

### 39-Redis6.0的新特性：多线程、客户端缓存与安全
![image](https://static001.geekbang.org/resource/image/21/f0/2155c01bf3129d5d58fcb98aefd402f0.jpg)
多IO线程、客户端缓存、细粒度的权限控制，以及RESP 3协议的使用。
单个主线程处理网络请求的速度跟不上底层网络硬件的速度。
Redis 6.0新增了一个重要的特性，就是实现了服务端协助的客户端缓存功能，也称为跟踪（Tracking）功能。依赖RESP 3协议。
如果数据被修改了或是失效了，如何通知客户端对缓存的数据做失效处理？
普通模式： 服务端记录客户端读取过的key，有变更则对client发invalidate消息。
CLIENT TRACKING ON|OFF
广播模式： 给客户端广播所有key的失效情况。即使客户端还没有读取过key，但只要它注册了要跟踪的key，服务端都会把key失效消息通知给这个客户端。
CLIENT TRACKING ON BCAST PREFIX user
RESP 2协议的客户端使用重定向模式（redirect）。 
```
//支持RESP 2的客户端B执行，客户端B的ID号是303
SUBSCRIBE _redis_:invalidate
//支持RESP 3的客户端A执行
CLIENT TRACKING ON BCAST REDIRECT 303
```
以用户为粒度设置命令操作的访问权限。
### 40-Redis的下一步：基于NVM内存的实践
这节课我向你介绍了NVM的三大特点：性能高、容量大、数据可以持久化保存。软件系统可以像访问传统DRAM内存一样，访问NVM内存。目前，Intel已经推出了NVM内存产品Optane AEP。

这款NVM内存产品给软件提供了两种使用模式，分别是Memory模式和App Direct模式。在Memory模式时，Redis可以利用NVM容量大的特点，实现大容量实例，保存更多数据。在使用App Direct模式时，Redis可以直接在持久化内存上进行数据读写，在这种情况下，Redis不用再使用RDB或AOF文件了，数据在机器掉电后也不会丢失。而且，实例可以直接使用持久化内存上的数据进行恢复，恢复速度特别快。

### 41-第35～40讲课后思考题答案及常见问题答疑
从可扩展性来看，Memcached优于Codis，Codis优于Redis Cluster。所以，如果实际业务需要大规模集群，建议你优先选择Codis或者是基于一致性哈希的Redis切片集群方案。
- Redis Cluster：使用Slot映射表并由实例扩散保存。
- Codis：使用Slot映射表并由第三方存储系统保存。
- Memcached：使用一致性哈希。

##### reference
https://yq.aliyun.com/articles/531067
https://help.aliyun.com/document_detail/26365.html


