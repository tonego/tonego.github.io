-- 《数据结构与算法之美》 - 王争
 
 [原文](http://xujl.site/2019/05/24/数据结构与算法之美/) | 
 [code](https://github.com/wangzheng0822/algo)

##### 1. 为何学

  面试、应用、开源框架、核心技能

##### 2. 重点

  10个数据结构:数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树;
  
  10个算法:递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。
   
#### 3. 时间复杂度

  asymptotic time complexity, 从低阶到高阶有:O(1)、O(logn)、O(n)、O(n*logn)、O(n^2)

  [时间复杂度](https://upload-images.jianshu.io/upload_images/1354448-d2f12e37539d8733.jpg)

#### 4. 最x复杂度

  best/worst/average/amortized case time complexity
  
#### 5. 数组

  数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。
  
  O(1)替换插入法：直接将第k位的数据搬移到数组元素的最后，把新的元素直接放入第k个位置。(快排)
  
  删除法: 先标记，后批量删除。 (JVM)
  
  访问越界问题。在C语言中是一种未决行为，不报错。
  
  容器ArrayList。 封装了插入删除动态扩容

  从0编号: 0是偏移量； 历史原因沿用C语言
 
#### 6. 链表

  CPU缓存、数据库缓存、浏览器缓存
  
  先进先出策略FIFO（First In，First Out）、最少使用策略LFU（Least Frequently Used）、最近最少使用策略LRU（Least Recently Used）
 
  单向、双向、循环、
  
  循环链表： 著名的约瑟夫问题
  
  vs数组: 非连续内存,无法借助CPU的缓存机制预读，访问效率低；支持动态扩容； 内存消耗会翻倍； 频繁的内存申请释放造成内存碎片频繁GC。
  
#### 7. 链表
  
  理解指针或引用的含义、警惕指针丢失和内存泄漏、利用哨兵节点(带头链表)简化实现难度、重点留意边界条件处理、画图、多练
  
  单链表反转 链表中环的检测 两个有序的链表合并 删除链表倒数第n个结点 求链表的中间结点
  
  针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。
  
  哨兵节点： 应用于 插入排序、归并排序、动态规划
  
  边界： 空节点、12节点、头尾节点、
  
#### 8. 栈
  
  栈是一种“操作受限”的线性表，只允许在一端插入和删除数据
  
  当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。
  
  用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。
  
  应用场景： 浏览器返回、函数调用、表达式求值、括号匹配
  
#### 9. 队列

  用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列
  
  数组实现循环列队避免搬迁操作
  
  阻塞队列实现“生产者-消费者模型”
  
  基于数组的循环队列，利用CAS原子操作，可以实现非常高效的并发队列。（Disruptor）
  
  链表支持无限排队的无界队列（unbounded queue），基于数组实现的有界队列（bounded queue）
  
  应用： 线程池
  
#### 10. 递归

  写递归代码最关键的是找到如何将大问题分解为小问题的规律，写出递推公式，找到终止条件
  
  设深度边界警惕堆栈溢出，通过散列表警惕重复计算，警惕无限递归问题
  
  利: 表达力强，简洁高效；弊: 堆栈溢出、重复计算、函数调用耗时多、空间复杂度高。
  
  将递归改为了“手动”递归

#### 11. 冒泡插入选择O(n^2)排序
  
  稳定的排序算法： 排序后等值顺序不变

#### 12. 归并快排O(n*logn)
  
  分治算法一般都是用递归来实现。
  
#### 13. 桶计数基数O(n)排序

  
  

#### 17. 跳表(二叉树&链表) ×

  高度h=logn. 第k级索引结点数n/(2^k),  最高级索引2=n/(2^h), h=log2n-1. 
  
  O(m*logn), m<=3
  
  空间复杂度. 
  
  用双链表是因为有删除插入操作需要找到前节点
  
  vs红黑树, 实现简单、区间查询效率高、更加灵活(改变索引构建策略 有效平衡执行效率和内存消耗)
  
  _这里若用三叉数来讲会更好_

#### 22. Hash

  安全加密、数据校验、唯一标识、散列函数、负载均衡、数据分片、分布式存储、CRC校验、Git commit id
  
#### 23. 二叉树

  高度、深度、层数;
  
  存储法: 链式:指针存储; 顺序: 适用完全二叉树、数组存储(左2i,右2i+1,父i/2)、
 
  前中后序遍历; 中序排序: if (root == null) return; inOrder(root->left); print root; inOrder(root->right);
  
#### 24. 二叉树

  vs散列表: 有序、扩容方便(平衡二叉查找树)、查找快，hash冲突&hash函数耗时O(N)不一定快于O(logN)、存储空间少
  
  重复数据：链表、右子树；  
  删除可用标识伪删除
  
#### 25. 红黑树

  1. 节点是黑色的；
  2. 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；
  3. 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
  4. 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点； 黑色节点数是颗完全二叉树
  
#### 26. 红黑树


#### 56. 短网址

  Hash法，后转62进制，存DB，冲突改原数据重新Hash，优化：唯一索引、布隆过滤器
  MurmurHash : Redis、MemCache、Cassandra、HBase、Lucene 
  
  ID生成器法， 重复生成问题、ID生成器性能问题
  
  
  
  
  
  
  
  
  
  
  
  