-- 《数据结构与算法之美》 - 王争
 
 [原文](http://xujl.site/2019/05/24/数据结构与算法之美/) | 
 [code](https://github.com/wangzheng0822/algo) | 
 [转载](https://time.geekbang.org/column/intro/126)

##### 1. 为何学

  面试、应用、开源框架、核心技能

##### 2. 重点

  10个数据结构:数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树;
  
  10个算法:递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。
   
#### 3. 时间复杂度

  asymptotic time complexity, 从低阶到高阶有:常量O(1)、对数O(logn)、线性O(n)、线性对数O(n*logn)、平方O(n^2)、指数O(2^n)、阶乘阶O(n!)

  [时间复杂度](https://upload-images.jianshu.io/upload_images/1354448-d2f12e37539d8733.jpg)

#### 4. 最x复杂度
  
  best/worst/average/amortized case time complexity
  
#### 5. 数组

  数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。
  
  O(1)替换插入法：直接将第k位的数据搬移到数组元素的最后，把新的元素直接放入第k个位置。(快排)
  
  删除法: 先标记，后批量删除。 (JVM)
  
  访问越界问题。在C语言中是一种未决行为，不报错。
  
  容器ArrayList。 封装了插入删除动态扩容

  从0编号: 0是偏移量； 历史原因沿用C语言
  
#### 6. 链表
  
  CPU缓存、数据库缓存、浏览器缓存
  
  先进先出策略FIFO（First In，First Out）、最少使用策略LFU（Least Frequently Used）、最近最少使用策略LRU（Least Recently Used）
 
  单向、双向、循环、
  
  循环链表： 著名的约瑟夫问题
  
  vs数组: 非连续内存,无法借助CPU的缓存机制预读，访问效率低；支持动态扩容； 内存消耗会翻倍； 频繁的内存申请释放造成内存碎片频繁GC。
  
#### 7. 链表
  
  理解指针或引用的含义、警惕指针丢失和内存泄漏、利用哨兵节点(带头链表)简化实现难度、重点留意边界条件处理、画图、多练
  
  单链表反转 链表中环的检测 两个有序的链表合并 删除链表倒数第n个结点 求链表的中间结点
  
  针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。
  
  哨兵节点： 应用于 插入排序、归并排序、动态规划
  
  边界： 空节点、1或2个节点、头尾节点、
  
#### 8. 栈
  
  栈是一种“操作受限”的线性表，只允许在一端插入和删除数据
  
  当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。
  
  用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。
  
  应用场景： 浏览器返回、函数调用、表达式求值、括号匹配
  
#### 9. 队列
  
  用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列
  
  数组实现循环列队避免搬迁操作
  
  阻塞队列实现“生产者-消费者模型”
  
  基于数组的循环队列，利用CAS原子操作，可以实现非常高效的并发队列。（Disruptor）
  
  链表支持无限排队的无界队列（unbounded queue），基于数组实现的有界队列（bounded queue）
  
  应用： 线程池
  
#### 10. 递归

  写递归代码最关键的是找到如何将大问题分解为小问题的规律，写出递推公式，找到终止条件
  
  设深度边界警惕堆栈溢出，通过散列表警惕重复计算，警惕无限递归问题
  
  利: 表达力强，简洁高效；弊: 堆栈溢出、重复计算、函数调用耗时多、空间复杂度高。
  
  将递归改为了“手动”递归
  
#### 11. 冒泡插入选择O(n^2)排序
  
  稳定的排序算法： 排序后等值顺序不变
  
  逆序度(作者自创词) = 满有序度( n*(n-1)/2 ) - 有序度
  
  冒泡，是稳定排序
  插入排序，比较+挨个移动，稳，应用广；
  选择排序，非稳；

#### 12. 归并快排O(n*logn) ※
  
  分治算法一般都是用递归来实现。
  
  T(n) = 2^kT(n/2^k)+kn。当T(n/2^k)=T(1)时，也就是n/2^k=1，我们得到k=log2n 。我们将k值代入上面的公式，得到T(n)=Cn+nlog2n 
  
  快排的prtition 类选择排序的分区间，类数组O(1)替换插入法。
  
  vs. 归并由下到上, 稳定, 非原地O(nlogn);
      快排由上到下,非稳定,原地
  
  _merge()合并函数如何借助哨兵?_ 

#### 13. 桶计数基数O(n)排序 
  
  线性排序（Linear sort），适用场景比较特殊
  
  Bucket sort: 区间分桶， 桶内用快排， 
  
  Counting sort: 分数或年龄排序。桶排序的特殊情况， 排序列范围较小。 临时数组(k:分数,v:<分的元素累计数;C[score]=sum(count))
  
  Radix sort: 手机号码排序。从后往前排序。
  
#### 14. 排序优化 ※

  快排优化找分区点：三数取中、随机取数、 
  
  Glibc中的qsort()函数：归并，快排三数取中，排序的区间中元素的个数小于等于4时退化为插入排序， 哨兵简化代码。
  
  选择排序方法不应只看时间复杂度。 时间复杂度代表的是一个增长趋势。 大O复杂度表示法中，我们会省略低阶、系数和常数。 小数据量下O(n^2)也可能更优
  
  golang: 快排+希尔排序+插排+堆排，len>12&recursionDeep>0快排三数取中; len>12&recursionDeep==0堆排; <12时用6作为gap做一次希尔排序，然后走一遍普通的插排（插排对有序度高的序列效率高）
  
  _当被要求写快排时，Redis/MySQL/Go的排序实现？_
  
#### 15. 二分查找

  对数对应的就是指数。有一个非常著名的“阿基米德与国王下棋的故事”
  
  易错点： 循环退出条件应为low<=high; mid=(low+high)/2 改 low+(high-low)/2 改 low+((high-low)>>1); 
  
  循环及递归实现
  
  适用场景： 有序静态数组；数据量不小&比较操作简单； 数据量不大
  
  
#### 16. 二分查找

  十个二分九个错： 唐纳德·克努特（Donald E.Knuth）在《计算机程序设计艺术》的第3卷《排序和查找》中说到：“尽管第一个二分查找算法于1946年出现，然而第一个完全正确的二分查找算法实现直到1962年才出现。”
  
  查找第一个值等于给定值的元素 最后一个等于 第一个大于等于 最后一个小于等于（快速定位出一个IP地址的归属地）
  
  二分查找更适合用在“近似”查找问题。凡是用二分查找能解决的，绝大部分我们更倾向于用散列表或者二叉查找树
  
  出错点： 终止条件、区间上下界更新方法、返回值选择。 
  
  [leetcode.33](https://leetcode.com/problems/search-in-rotated-sorted-array/)

#### 17. 跳表(二叉树&链表) ×

  高度h=logn. 第k级索引结点数n/(2^k),  最高级索引2=n/(2^h), h=log2n-1. 
  
  O(m*logn), m<=3
  
  空间复杂度. 
  
  用双链表是因为有删除插入操作需要找到前节点
  
  vs红黑树, 实现简单、区间查询效率高、更加灵活(改变索引构建策略 有效平衡执行效率和内存消耗)
  
  _这里若用三叉数来讲会更好_

#### 18. 散列表

  散列表两个核心问题是散列函数设计和散列冲突解决
  
  MD5、SHA、CRC等哈希算法
  
  散列冲突： open addressing (Linear Probing/ Quadratic probing/ Double hashing) 、chaining; load factor
  
  _如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效, 怎么理解？_
  
  
#### 19. 工业级散列表

  动态分步扩缩容、散列碰撞攻击、如何设计散列函数，如何根据装载因子动态扩容，以及如何选择散列冲突解决方法
  
  散列函数： 直接寻址法、平方取中法、折叠法、随机数法
  
  开放寻址法；可利用CPU缓存查询快、 序列化容易、冲突代价高装载因子小浪费空间； 适用数据量比较小、装载因子小，如ThreadLocalMap(线性探测)
  
  链表法；链表空间按需申请内存利用率高、链表过大可用用红黑树代替链表； 适合存储大对象、大数据量的散列表 如LinkedHashMap 
  
  Java中的HashMap： 16， 0.75， 链表， 红黑树
  
#### 20. 散列表+链表

  LRU: 存储数据（data）、前驱指针（prev）、后继指针（next）、拉链(hnext)
  
  ZSET: hash+跳表
  
  LinkedHashMap 插入/访问顺序遍历。 是通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap中的“Linked”实际上是指的是双向链表，并非指用链表法解决散列冲突。
  
#### 21. 哈希算法应用
 
  针对字典攻击引入一个盐（salt）
 
#### 22. Hash分布式应用

  安全加密、数据校验、唯一标识、散列函数、负载均衡、数据分片、分布式存储、CRC校验、Git commit id
  
#### 23. 二叉树

  高度、深度、层数;
  
  存储法: 链式:指针存储; 顺序: 适用完全二叉树、数组存储(左2i,右2i+1,父i/2)、
 
  前中后序遍历; 中序排序: if (root == null) return; inOrder(root->left); print root; inOrder(root->right);
  
#### 24. 二叉树

  vs散列表: 有序、扩容方便(平衡二叉查找树)、查找快，hash冲突&hash函数耗时O(1)不一定快于O(logN)、存储空间少
  
  重复数据：链表、右子树；  
  删除：可用标识伪删除
  
#### 25. 红黑树

  1. 节点是黑色的；
  2. 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；
  3. 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
  4. 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点； 黑色节点树是颗完全四叉树
  
#### 26. 红黑树 todo 

  把红黑树的平衡调整的过程比作魔方复原，不要过于深究这个算法的正确性；找准关注节点；插入操作的平衡调整比较简单，但是删除操作就比较复杂

#### 27. 递归树 todo
 
  归并、快排、斐波那契数列
  
#### 28. 堆排序
  
  1. 堆是一个完全二叉树；
  2. 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值
  
  插入： 从下往上堆化（heapify）
  删除： 防止删除堆顶导致的数组空洞，采用从上往下的堆化方法，先把最后一个节点放到堆顶，后互换
  
  堆排序： 建堆O(n)和排序O(log n)。我们将下标从n/2到1的节点，依次进行从上到下的堆化操作，然后就可以将数组中的数据组织成堆这种数据结构。
  接下来，我们迭代地将堆顶的元素放到堆的末尾，并将堆的大小减一，然后再堆化，重复这个过程，直到堆中只剩下一个元素，整个数组中的数据就都有序排列了。
  
  vs快排， CPU缓存不友好； 交换次数过多，建堆过程有序度被破坏；

#### 29. 堆应用
  
  优先级队列: 赫夫曼编码(http2)、图的最短路径、最小生成树算法。 Java的PriorityQueue，C++的priority_queue。 合并有序小文件(MySQL)、高性能定时器
  
  求Top K： O(nlogK) , redis Tok-k算法使用减治法(先用随机选择（快排分大小区间）找到第k大的数，再进行一次partition)
  
  求中位数： 动态数据集合，维护大小顶堆。 求其他百分位的数据， 求接口的99%响应时间。
  
  包含10亿个搜索关键词的日志文件快速获取到Top 10最热门的搜索关键词, MapReduce, hash词分片10个文件后散列表堆最后合并
 
#### 30. 图

  无向图、有向图、带权图、顶点、边、度、入度、出度
  
  邻接矩阵存储方法的缺点是比较浪费空间，但是优点是查询效率高，而且方便矩阵运算。
  邻接表存储方法中每个顶点都对应一个链表，存储与其相连接的其他顶点，节省存储空间，不方便查找，所以查询效率低。链表改进平衡二叉查找树、跳表、散列表等。

  如何存储微博、微信等社交网络中的好友关系？邻接表中存储了用户的关注关系，逆邻接表中存储的是用户的被关注关系，跳表、mysql
  
#### 31. 深度和广度优先搜索：如何找出社交网络中的三度好友关系

  给你一个用户，如何找出这个用户的所有三度（其中包含一度、二度和三度）好友关系？
  
  BFS, Breadth-First-Search： visited、queue、prev 实现。O(V+E)。
  
  DFS, Depth-First-Search: 回溯思想, prev、visited、found、print()
  
#### 32. 字符串匹配

  BF, Brute Force，暴力匹配算法，也叫朴素匹配算法。 主串和模式串. 最坏情况时间复杂度是O(n*m).  KISS（Keep it Simple and Stupid）设计原则
  
  RK, Rabin-Karp算法, 对每个子串分别求哈希值, 时间复杂度是O(n).
  
#### 33. BM字符串匹配, 

  BM（Boyer-Moore）算法, 是著名的KMP算法的3到4倍. 好后缀和坏字符规则

#### 34. KMP字符串匹配

  Knuth Morris Pratt算法,
  
#### 35. Trie树

  Trie树，也叫“字典树”, 查找前缀匹配的字符串

#### 36. AC自动机：如何用多模式串匹配实现敏感词过滤功能

  单模式: BF算法、RK算法、BM算法、KMP算法； 多模式: Trie树、AC自动机
  
  AC自动机, Aho-Corasick算法, 实际上就是在Trie树之上，加了类似KMP的next数组，只不过此处的next数组是构建在树上罢了
  
#### 37. 贪心算法：如何用贪心算法实现Huffman压缩编码
  
  贪心算法（greedy algorithm）。贪心算法有很多经典的应用，比如霍夫曼编码（Huffman Coding）、Prim和Kruskal最小生成树算法、还有Dijkstra单源最短路径算法
  
  Huffman： 对数据压缩编码，有效节省数据存储空间。 
  
  1. 联想到贪心算法：针对一组数据，我们定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大。
  2. 是否可以用贪心算法
  3. 举几个例子看下贪心算法产生的结果是否是最优的
  
  背包装豆子、分糖果、钱币找零、区间覆盖、
  
#### 38. 分治算法

  分治算法（divide and conquer）

#### 39. 回溯算法 
  
  深度优先搜索、正则表达式匹配、编译原理中的语法分析； 数独、八皇后、0-1背包、图的着色、旅行商问题、全排列
  
  递归实现、剪枝操作
  
#### 40. 初识动态规划：如何巧妙解决“双十一”购物时的凑单问题

  0-1背包问题回溯解、二维数组解、一维数组解、加价值条件解、算所有组合解
  
  大部分动态规划能解决的问题，都可以通过回溯算法来解决
  
  * 贪心：一条路走到黑，就一次机会，只能哪边看着顺眼走哪边；
  * 回溯：一条路走到黑，无数次重来的机会，还怕我走不出来 (Snapshot View)；
  * 动态规划：拥有上帝视角，手握无数平行宇宙的历史存档， 同时发展出无数个未来 (Versioned Archive View)；
  
#### 41. 动态规划理论
  
  一个模型三个特征： 多阶段决策最优解模型、最优子结构、无后效性和重复子问题
  
  1. 状态转移表法。 回溯算法实现-定义状态-画递归树-找重复子问题-画状态转移表-根据递推关系填表-将填表过程翻译成代码
  2. 状态转移方程法。 找最优子结构-写状态转移方程-将状态转移方程翻译成代码. 递归加“备忘录”， 迭代递推。 状态转移方程是解决动态规划的关键

  分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题
  
  贪心算法实际上是动态规划算法的一种特殊情况。 最优子结构、无后效性和贪心选择性(由局部最优解构成全局最优解)
  
#### 42. 动态规划实战：如何实现搜索引擎中的拼写纠错功能
  
  量化两个字符串的相似度。 Edit Distance. 莱文斯坦距离（Levenshtein distance）和最长公共子串长度（Longest common substring length）
  
#### 43. 拓扑排序：如何确定代码源文件的编译依赖关系

  如何在这个有向无环图上，实现拓扑排序，Kahn算法和DFS深度优先搜索算法。
  
  凡是需要通过局部顺序来推导全局顺序的，一般都能用拓扑排序来解决。 检测图中环的存在
  
#### 44. 最短路径：地图软件是如何计算出最优出行路径的

  有向有权图中，求两个顶点间的最短路径
  
  单源最短路径算法（一个顶点到一个顶点）Dijkstra算法
  
#### 45. 位图&布隆过滤器：如何实现网页爬虫中的URL去重功能

  降低冲突： 使用K个哈希函数，对同一个数字进行求哈希值。我们用K个二进制位，来表示一个数字的存在。
  
  只会对存在的情况有误判，为true不一定，为false是一定的
  
  Java中的BitSet类就是一个位图，Redis也提供了BitMap位图类
  
#### 46. 概率统计：如何利用朴素贝叶斯算法过滤垃圾短信

  P(A|B) = P(B|A)*P(A)/P(B)
  
#### 47. 向量空间：如何实现一个简单的音乐推荐系统
  
  欧几里得距离（Euclidean distance）(高的差的平方+长差平方)的根号
  
  基于相似用户/歌曲做推荐
  
#### 50. 索引

  数据是/否格式化数据、静/动态数据、存在内存/硬盘、单值/区间查找、单/多关键词组合查找
  
  散列表、红黑树、跳表、位图、布隆过滤器、有序数组
  
#### 55. 剖析微服务接口鉴权限流背后的数据结构和算法

  固定时间窗口限流算法、滑动时间窗口限流算法(循环队列，类LRU)、令牌桶算法、漏桶算法
  
#### 56. 短网址

  Hash法，后转62进制，存DB，冲突改原数据重新Hash，优化：唯一索引、布隆过滤器
  MurmurHash : Redis、MemCache、Cassandra、HBase、Lucene 
  
  ID生成器法， 重复生成问题、ID生成器性能问题
  
## 思考
#### 排序算法
  场景考虑： 重复多用三路归并，近乎有序用插入，取值范围有限用计数，稳定排序用归并， 链表存储用归并， 数据大小问题
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  